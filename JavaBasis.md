#### 接口和抽象类的区别和共同点
共同点：  
+ 都不能被实例化。
+ 都可以包含抽象方法。
+ 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。

区别：  
+ 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。
+ 一个类只能继承一个类，但是可以实现多个接口。
+ 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。
#### 深拷贝和浅拷贝
+ 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
+ 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
####Object类
##### ==和equais()
+ 对于基本数据类型来说，== 比较的是值。
+ 对于引用数据类型来说，== 比较的是对象的内存地址。  

equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。  
equals() 方法存在两种使用情况：
+ 类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。
+ 类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。
##### hashCode()
hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。
+ 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。
+ 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。
+ 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。  

#### java并发
##### 线程
线程私有资源：程序计数器、虚拟机栈和本地方法栈。
线程共享资源：堆和方法区 (JDK1.8 之后的元空间)。
##### 程序计数器为什么是私有的？
程序计数器主要有下面两个作用：
+ 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
+ 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。
##### sleep() 方法和 wait() 方法区别和共同点?
+ 两者最主要的区别在于：sleep()方法没有释放锁，而wait()方法释放了锁 。
+ 两者都可以暂停线程的执行。
+ wait()通常被用于线程间交互/通信，sleep()通常被用于暂停执行。
+ wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。
sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。
##### 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法?
new一个Thread，线程进入了新建状态。
调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。
start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。
但是，直接执行run()方法，会把run()方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。  
**总结**： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。
##### synchronized关键字
synchronized 关键字解决的是多个线程之间访问资源的同步性，
synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。